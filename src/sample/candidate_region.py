#!/usr/bin/env python
# Copyright 2023 Z Zhang

# BioSeq2Seq, Version 1.0;
# you may not use this file except in compliance with the License.
# Use of this code requires following originality guidelines
# and declaring the source of the code.
# email:zhichunli@mail.dlut.edu.cn
# =========================================================================

import sys
import os
import subprocess
import shutil


def split_contigs(chrom_segments, gaps_file):
    """ 
    Remove genomic intervals recorded in gap_file from genomic regions

        Args:
        chrom_segments: the range of each chromosome (start,end)
        gaps_file: the file of the interval that needs to be removed

        Returns:
        chrom_segments: same, with segments broken by the assembly gaps.
    """

    chrom_events = {}

    # add known segments
    for chrom in chrom_segments:
        if len(chrom_segments[chrom]) > 1:
            raise Exception(
                "I've made a terrible mistake...regarding the length of chrom_segments[%s]"
                % chrom,
                file=sys.stderr)

        cstart, cend = chrom_segments[chrom][0]
        chrom_events.setdefault(chrom, []).append((cstart, 'Cstart'))
        chrom_events[chrom].append((cend, 'cend'))

    # add gaps
    for line in open(gaps_file):
        a = line.split()
        chrom = a[0]
        gstart = int(a[1])
        gend = int(a[2])

        # consider only if its in our genome
        if chrom in chrom_events:
            chrom_events[chrom].append((gstart, 'gstart'))
            chrom_events[chrom].append((gend, 'Gend'))
 
    # determine whether the interval after division is overlapped
    for chrom in chrom_events:
        # sort
        chrom_events[chrom].sort()

        # read out segments
        chrom_segments[chrom] = []

        for i in range(len(chrom_events[chrom]) - 1):
            pos1, event1 = chrom_events[chrom][i]
            pos2, event2 = chrom_events[chrom][i + 1]

            event1 = event1.lower()
            event2 = event2.lower()

            shipit = False
            if event1 == 'cstart' and event2 == 'cend':
                shipit = True
            elif event1 == 'cstart' and event2 == 'gstart':
                shipit = True
            elif event1 == 'gend' and event2 == 'gstart':
                shipit = True
            elif event1 == 'gend' and event2 == 'cend':
                shipit = True
            elif event1 == 'gstart' and event2 == 'gend':
                pass
            else:
                print(
                    "I'm confused by this event ordering: %s - %s" % (event1, event2),
                    file=sys.stderr)
                print(pos1, pos2)
                exit(1)

            if shipit and pos1 < pos2:
                chrom_segments[chrom].append((pos1, pos2))

    return chrom_segments


def get_removal_candidates(temporary_path=None, remove_bed_file=None, remove_file_list=[]):
    """ 
    Statistics and integration of genomic regions that need to be removed

    Args:
        temporary_path: temporary files, used to store files generated by commands such as bedtools
        remove_bed_file: the integrated genome region file that needs to be removed
        remove_file_list: genomic region files to remove

    Returns:
        merge_path: the path of the integrated genome region file that needs to be removed.
    """
    if os.path.isfile(remove_bed_file):
        os.remove(remove_bed_file)

    for remove_file in remove_file_list:
        cmd = 'cat ' + remove_file + ' >> ' + remove_bed_file
        p = subprocess.Popen(cmd, shell=True)
        p.wait()

    # sort
    sort_path = os.path.join(temporary_path, 'sorted_gap.bed')
    sort_cmd = 'sort-bed ' + remove_bed_file + ' > ' + sort_path
    p = subprocess.Popen(sort_cmd, shell=True)
    p.wait()

    # merge
    # merge_path = os.path.join(temporary_path, 'merged_remove.bed')
    merge_cmd = 'bedtools merge -i ' + sort_path + ' > ' + remove_bed_file
    p = subprocess.Popen(merge_cmd, shell=True)
    p.wait()
    

    # 试试是不是不一样了，按说没事


    return remove_bed_file

# remove_useless_regions
def select_candidate_regions(genome_region={}, blacklist_file=None, except_bed_file=[], include_chr=None, except_chr=None):
    """ 
    Get the candidate regions by remove the useless regions

    Args:
        genome_region: complete genome region, dict:{chr:[(start, end)], ...}
        blacklist_file: blacklist file
        except_bed_file: regions that need to be removed except blacklist
        include_chr: chromosomal data needed for training or prediction
        except_chr: chromosome data not needed for training or prediction

    Return:
        candidate_region: candidate regions  dict:{chr:[(start0, end0), (start1, end1)], ...}
    """
    candidate_region = {}

    # get length of each chromosome
    if len(include_chr) > 0:
        for chr in include_chr:
            candidate_region[chr]=genome_region[chr]
    elif len(except_chr) > 0:
        for chr in genome_region:
            if not(chr in except_chr):
                candidate_region[chr]=genome_region[chr]
    else:
        for chr in genome_region:
            candidate_region[chr]=genome_region[chr]
  
    # get remove file list
    temporary_path = os.path.join(os.path.dirname(__file__), 'temporary')
    if not(os.path.isdir(temporary_path)):
        os.mkdir(temporary_path)

    remove_bed_file = os.path.join(temporary_path, 'remove.bed')
    if blacklist_file is not None:
        remove_file_list = [blacklist_file]
    else:
        remove_file_list = []
    if len(except_bed_file) > 0:
        for bed_file in except_bed_file:
            remove_file_list.append(bed_file)

    # get regions to be removed
    if len(remove_file_list) != 0:
        removal_candidate_file = get_removal_candidates(temporary_path, remove_bed_file, remove_file_list)
        
        # remove regions
        candidate_region = split_contigs(candidate_region, removal_candidate_file)

    # remove temporary files
    shutil.rmtree(temporary_path)

    return candidate_region